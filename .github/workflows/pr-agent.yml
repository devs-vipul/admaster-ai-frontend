name: ðŸ¤– AI PR Summary

on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  pr-summary:
    name: ðŸ“ Generate Smart PR Summary
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'reopened' || github.event.action == 'synchronize')
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ¤– Generate Intelligent Summary
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });

            // Analyze commit messages to understand WHAT was done
            const commitMessages = commits.map(c => c.commit.message);
            const allCommitText = commitMessages.join('\n').toLowerCase();

            // Detect types of changes from commits
            const changeTypes = {
              features: /feat|feature|add|implement|create/i.test(allCommitText),
              fixes: /fix|bug|resolve|patch/i.test(allCommitText),
              refactor: /refactor|improve|optimize|clean/i.test(allCommitText),
              docs: /docs|documentation|readme/i.test(allCommitText),
              style: /style|css|ui|design/i.test(allCommitText),
              tests: /test|spec/i.test(allCommitText),
              ci: /ci|workflow|action|pipeline/i.test(allCommitText),
              config: /config|setup/i.test(allCommitText),
            };

            // Analyze what actually changed
            const keyFiles = {
              components: files.filter(f => f.filename.includes('/components/')),
              pages: files.filter(f => f.filename.includes('/app/') && f.filename.endsWith('.tsx')),
              workflows: files.filter(f => f.filename.includes('.github/workflows')),
              configs: files.filter(f => /config|tsconfig/.test(f.filename)),
              deps: files.filter(f => f.filename.includes('package')),
              styles: files.filter(f => /\.(css|scss)$/.test(f.filename)),
            };

            // Build SMART summary based on actual changes
            let description = `## ðŸŽ¯ What This PR Does\n\n`;

            // Intelligently describe the changes
            const changes = [];
            if (changeTypes.features && keyFiles.components.length > 0) {
              changes.push(`âœ¨ **New Features:** Added/updated ${keyFiles.components.length} component(s)`);
            }
            if (changeTypes.fixes) {
              changes.push(`ðŸ› **Bug Fixes:** Resolved issues and bugs`);
            }
            if (changeTypes.ci && keyFiles.workflows.length > 0) {
              changes.push(`ðŸ”§ **CI/CD:** Updated GitHub Actions workflows (${keyFiles.workflows.length} file(s))`);
            }
            if (changeTypes.config && keyFiles.configs.length > 0) {
              changes.push(`âš™ï¸ **Configuration:** Modified project configs`);
            }
            if (changeTypes.style && keyFiles.styles.length > 0) {
              changes.push(`ðŸŽ¨ **Styling:** Updated styles and UI`);
            }
            if (changeTypes.docs) {
              changes.push(`ðŸ“ **Documentation:** Updated docs or README`);
            }
            if (changeTypes.refactor) {
              changes.push(`â™»ï¸ **Refactoring:** Code improvements and cleanup`);
            }
            if (keyFiles.deps.length > 0) {
              changes.push(`ðŸ“¦ **Dependencies:** Package updates`);
            }

            if (changes.length > 0) {
              changes.forEach(c => description += `- ${c}\n`);
            } else {
              description += `- ðŸ”„ General code updates and improvements\n`;
            }

            description += `\n### ðŸ“ Key Changes\n\n`;

            // List actual important files
            const importantFiles = [...keyFiles.components, ...keyFiles.pages, ...keyFiles.workflows]
              .slice(0, 8);

            if (importantFiles.length > 0) {
              importantFiles.forEach(f => {
                const icon = f.filename.includes('component') ? 'ðŸ§©' : 
                            f.filename.includes('workflow') ? 'ðŸ”§' : 
                            f.filename.includes('page') ? 'ðŸ“„' : 'ðŸ“';
                description += `- ${icon} \`${f.filename}\`\n`;
              });
              if (files.length > importantFiles.length) {
                description += `- ... and ${files.length - importantFiles.length} more file(s)\n`;
              }
            }

            // Add stats
            description += `\n### ðŸ“Š Stats\n`;
            description += `\`\`\`\n`;
            description += `ðŸ“ Commits:       ${commits.length}\n`;
            description += `ðŸ“‚ Files changed:  ${files.length}\n`;
            description += `âž• Additions:     +${pr.additions}\n`;
            description += `âž– Deletions:     -${pr.deletions}\n`;
            description += `\`\`\`\n\n`;

            // Check for important warnings
            const warnings = [];
            if (keyFiles.deps.length > 0) warnings.push('ðŸ“¦ **Dependencies updated** - Review carefully');
            if (keyFiles.workflows.length > 0) warnings.push('ðŸ”§ **CI/CD modified** - Test all workflows');
            if (pr.additions + pr.deletions > 1000) warnings.push('ðŸš¨ **Large PR** - Consider breaking up');

            if (warnings.length > 0) {
              description += `### âš ï¸ Important Notes\n\n`;
              warnings.forEach(w => description += `- ${w}\n`);
              description += `\n`;
            }

            description += `---\n\n`;
            description += `ðŸ¤– *AI-generated summary â€¢ [View all changes](${pr.html_url}/files)*`;

            // UPDATE THE PR DESCRIPTION (not just comment)
            try {
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                body: description
              });
              
              core.info('âœ… PR description updated with AI summary');
            } catch (error) {
              core.warning(`Could not update PR description: ${error.message}`);
              
              // Fallback to comment if can't update description
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: description
              });
            }
